<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Card Board</title>
	<!-- Use EasyMDE CDN -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css">
    <style>
        /* === Base Styles === */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            min-height: 100vh;
        }

        /* === General Button & Label Styling === */
        button,
        .file-upload-label { /* Base styles for most buttons/labels acting like buttons */
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em; /* Default size, can be overridden */
            transition: background-color 0.2s ease;
            display: inline-flex; /* Use flex for alignment */
            align-items: center;
            justify-content: center;
            text-align: center; /* Center text by default */
            line-height: 1.4; /* Default line height */
            white-space: nowrap; /* Prevent wrapping by default */
        }

        button:hover,
        .file-upload-label:hover {
            background-color: #0056b3;
        }

        /* === Control Bar (Top Grid) === */
        .controls-grid {
            display: grid;
            grid-template-columns: auto auto 1fr auto auto; /* AddBtn | Checkbox | Search | Export | Import */
            grid-template-rows: auto auto; /* Controls row | Status row */
            align-items: center;
            gap: 10px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        /* Grid Item Placements */
        .controls-grid #add-card-btn { grid-column: 1; grid-row: 1; }
        .controls-grid .checkbox-wrapper { grid-column: 2; grid-row: 1; }
        .controls-grid .ai-search-wrapper { grid-column: 3; grid-row: 1; }
        .controls-grid #export-btn { grid-column: 4; grid-row: 1; }
        .controls-grid .file-upload-label { grid-column: 5; grid-row: 1; }
        .controls-grid #ai-status { grid-column: 3; grid-row: 2; }

        /* Control Bar - Specific Element Styling */
        .controls-grid .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .controls-grid .checkbox-wrapper label {
             margin-bottom: 0;
             /* Consider adjusting font-size/line-height if needed */
        }

        .controls-grid .ai-search-wrapper {
            width: 100%; /* Ensure wrapper takes full column width */
        }

        .controls-grid .ai-search-row {
            display: flex;
            gap: 5px;
            width: 100%;
        }

        .controls-grid #ai-search-input {
            flex-grow: 1;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            min-width: 100px;
        }

        /* Control Bar - Smaller Buttons (Search, Summarize, Export, Import) */
        .controls-grid #ai-search-btn,
        .controls-grid #ai-summarize-btn,
        .controls-grid #export-btn,
        .controls-grid .file-upload-label {
            font-size: 0.85em;   /* Reduced font size */
            line-height: 1.3;    /* Adjusted line height */
            white-space: normal; /* Allow text wrapping */
            padding: 8px 10px;   /* Adjusted padding */
            flex-shrink: 0;      /* Prevent shrinking in flex layout */
        }
         /* Only Search/Summarize need flex-shrink in the ai-search-row context,
            but applying to all small buttons here is harmless */

        /* Control Bar - AI Status Text */
        .controls-grid #ai-status {
            margin-top: 2px;
            padding-left: 2px;
            font-style: italic;
            color: #555;
            font-size: 0.85em;
        }

        /* Hidden file input */
        #import-file {
            display: none;
        }

        /* === Card Container & Drag/Drop === */
        #card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 10px;
            min-height: 300px;
            position: relative; /* For drop line */
        }

        .drop-line-indicator {
            position: absolute;
            top: 10px;
            bottom: 10px;
            width: 3px;
            background-color: #007bff;
            border-radius: 2px;
            opacity: 0.7;
            pointer-events: none;
            display: none;
            z-index: 5;
            transition: left 0.1s ease-out, top 0.1s ease-out, height 0.1s ease-out; /* Added more transitions */
        }

        /* === Card Styling === */
        .card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            width: 250px;
            display: flex;
            flex-direction: column;
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease, outline 0.3s ease-in-out;
            position: relative;
            order: var(--order, 0);
            flex-shrink: 0;
        }

        .card.dragging {
            opacity: 0.5;
            cursor: grabbing;
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
            transform: scale(1.05);
            z-index: 10;
        }

        .card.highlighted-card {
            outline: 3px solid #007bff;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
            /* Transition is already on the base .card */
        }

        .card.status-closed {
            text-decoration: line-through;
            color: #888;
             /* Consider reducing opacity slightly too */
             /* opacity: 0.8; */
        }
        .card.status-closed .card-title,
        .card.status-closed .card-content {
            color: #888; /* Ensure content also gets greyed out */
        }
        .card.status-closed .priority-label {
             opacity: 0.7; /* Dim priority label for closed cards */
        }


        /* Card Content Elements */
        .card-title {
            margin: 0 0 5px 0;
            font-size: 1.2em;
            font-weight: bold;
            word-wrap: break-word;
            color: #333; /* Explicit default color */
        }

        .card-meta {
            font-size: 0.8em;
            color: #666;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .card-meta div {
            margin-bottom: 3px;
        }
        .card-meta strong {
             color: #444; /* Slightly darker labels */
             min-width: 55px;
             display: inline-block;
             font-weight: 600;
        }

        /* Card Metadata Labels */
        .priority-label {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            line-height: 1.2; /* Adjust line height for small label */
        }
        .priority-high { background-color: #dc3545; }
        .priority-medium { background-color: #ffc107; color: #333; }
        .priority-low { background-color: #28a745; }

        /* Card Content Area */
        .card-content {
            flex-grow: 1;
            margin-bottom: 15px;
            word-wrap: break-word;
            overflow-y: auto;
            max-height: 200px;
            font-size: 0.95em;
            color: #333; /* Explicit default color */
            line-height: 1.5; /* Improve readability */
        }

        /* Card Content Markdown Styles */
        .card-content h1,
        .card-content h2,
        .card-content h3 { margin: 0.7em 0 0.3em 0; font-size: 1.1em; font-weight: 600; }
        .card-content p { margin: 0.5em 0; }
        .card-content ul,
        .card-content ol { margin: 0.5em 0; padding-left: 1.7em; }
        .card-content li { margin-bottom: 0.25em; }
        .card-content code { background-color: #eee; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
        .card-content pre { background-color: #eee; padding: 10px; border-radius: 3px; overflow-x: auto; font-family: monospace; font-size: 0.9em; margin: 0.8em 0; }
        .card-content blockquote { border-left: 3px solid #ccc; margin: 0.8em 0; padding-left: 1em; color: #666; }
        .card-content a { color: #007bff; text-decoration: none; }
        .card-content a:hover { text-decoration: underline; }

        /* Card Actions (Buttons at bottom of card) */
        .card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 5px;
            margin-top: auto; /* Pushes actions to the bottom */
        }

        .card-actions button { /* Specific styles for buttons inside cards */
            padding: 5px 10px;
            font-size: 0.9em;
            white-space: nowrap; /* Keep these buttons single line */
        }

        .card-actions .edit-btn { /* Inherits base button styles */
            background-color: #ffc107;
            color: #333;
        }
        .card-actions .edit-btn:hover {
            background-color: #e0a800;
        }

        .card-actions .delete-btn { /* Inherits base button styles */
            background-color: #dc3545;
            color: white; /* Explicitly set white */
        }
        .card-actions .delete-btn:hover {
            background-color: #c82333;
        }

        /* === Modal Styling === */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Add subtle shadow */
        }

        .modal-content h2 {
            margin-top: 0;
            margin-bottom: 20px; /* Add space below title */
            font-size: 1.5em; /* Slightly larger modal title */
            color: #333;
        }

        /* Modal Form Elements */
        .modal-content .form-group {
             margin-bottom: 20px; /* Increased spacing */
        }
        .modal-content label {
            display: block;
            margin-bottom: 8px; /* Increased space below label */
            font-weight: bold;
            color: #555;
        }

        .modal-content input[type="text"],
        .modal-content input[type="datetime-local"],
        .modal-content select,
        .modal-content .EasyMDEContainer textarea /* Target EasyMDE via its container */
         {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 0; /* Remove margin-bottom here, handled by form-group */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
        }
         /* Specific style adjustment for EasyMDE */
        .modal-content .EasyMDEContainer {
             border: 1px solid #ccc; /* Add border around EasyMDE */
             border-radius: 4px;
        }
         .modal-content .CodeMirror {
              border: none; /* Remove default CodeMirror border */
         }


        /* Modal Metadata Fields Layout */
        .modal-content .meta-fields {
			display: flex;
			gap: 15px; /* Increased gap */
			justify-content: space-between;
			flex-wrap: wrap;
            margin-bottom: 10px; /* Space below meta fields */
		}
		.modal-content .meta-fields .form-group {
			flex: 1; /* Share space */
			min-width: 160px; /* Prevent shrinking too much */
            margin-bottom: 10px; /* Spacing within the flex row */
		}

        /* Modal Editor Toolbar */
		.modal-content .editor-toolbar {
			background: #f0f0f0; /* Lighter background */
			border: 1px solid #ccc;
            border-bottom: none; /* Attach to top of editor */
			padding: 4px;
			border-radius: 4px 4px 0 0; /* Rounded top corners */
            margin-bottom: 0; /* Remove default margin */
		}
		.modal-content .editor-toolbar button {
            /* Inherits base button styles */
			color: #333; /* Darker icon color */
			background-color: transparent;
			border: none;
			padding: 6px; /* Slightly larger padding */
            font-size: 1em; /* Reset font size if base changed it */
		}
        .modal-content .editor-toolbar button:hover {
             background-color: #ddd; /* Subtle hover */
        }


        /* Modal Action Buttons */
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px; /* More space above buttons */
        }
        /* Modal buttons inherit base styles */
        .modal-actions #cancel-edit-btn {
            background-color: #6c757d;
        }
        .modal-actions #cancel-edit-btn:hover {
            background-color: #5a6268;
        }
        /* #save-card-btn uses the default blue */


        /* === Summary Popup Styles === */
        /* (These styles only apply inside the popup window) */
        /* Grouped here for clarity, even though they aren't used by the main page */
        .summary-popup-content { /* This class is used INSIDE the popup's HTML */
             font-family: sans-serif;
             padding: 20px 25px; /* More horizontal padding */
             font-size: 15px;
             line-height: 1.6;
             /* Styles below moved to popup's internal <style> tag for encapsulation */
        }
        /* Removed detailed popup styles from main CSS as they are now embedded */
        /* in the popup's generated HTML for better isolation. */
    </style>
</head>
<body>

	<div class="controls-grid">
		<button id="add-card-btn">Add New Card</button>

		<div class="checkbox-wrapper">
			<label for="show-open-only-checkbox">Show<br>Open</label>
			<input type="checkbox" id="show-open-only-checkbox" checked>
		</div>

		<div class="ai-search-wrapper">
			<div class="ai-search-row">
				<input type="search" id="ai-search-input" placeholder="AI Query... (Data sent to Google AI API)">
				<button id="ai-search-btn">AI Search</button>
                <!-- <<< START NEW BUTTON >>> -->
                <button id="ai-summarize-btn">AI Summarize</button>
                <!-- <<< END NEW BUTTON >>> -->
			</div>
		</div>

		<span id="ai-status"></span>

		<button id="export-btn">Export Cards (JSON)</button>
		<label for="import-file" class="file-upload-label">Import Cards (JSON)</label>
		<input type="file" id="import-file" accept=".json">
	</div>

    <div id="card-container">
        <!-- Cards will be loaded here -->
        <!-- NEW: Drop Line Indicator Element -->
        <div class="drop-line-indicator"></div>
    </div>

    <!-- Add/Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Edit Card</h2>
            <form id="edit-form">
                <input type="hidden" id="edit-id">
                <div class="form-group">
                    <label for="edit-title">Title:</label>
                    <input type="text" id="edit-title" required>
                </div>
                <!-- NEW Metadata Fields -->
				<div class="meta-fields">
					<div class="form-group">
						<label for="edit-created-at">Date Created:</label>
						<input type="datetime-local" id="edit-created-at">
					</div>
					 <div class="form-group">
						<label for="edit-status">Status:</label>
						<select id="edit-status">
							<option value="Open">Open</option>
							<option value="Closed">Closed</option>
						</select>
					</div>
					 <div class="form-group">
						<label for="edit-priority">Priority:</label>
						<select id="edit-priority">
							<option value="Low">Low</option>
							<option value="Medium" selected>Medium</option> <!-- Default selected -->
							<option value="High">High</option>
						</select>
					</div>
				</div>
                <!-- End NEW Fields -->
                <div class="form-group">
                    <label for="edit-markdown">Content (Markdown):</label>
                    <textarea id="edit-markdown"></textarea> <!-- EasyMDE will attach here -->
                </div>
                <div class="modal-actions">
                    <button type="button" id="cancel-edit-btn">Cancel</button>
                    <button type="submit" id="save-card-btn">Save Card</button>
                </div>
            </form>
        </div>
    </div>
	
	<!-- Ko-Fi -->
	<!-- Super Easy to Remove this and rob me from some money, Peace !! -->
	<script type='text/javascript' src='https://storage.ko-fi.com/cdn/widget/Widget_2.js'></script><script type='text/javascript'>kofiwidget2.init('Support me on Ko-fi', '#72a4f2', 'J3J21D24XG');kofiwidget2.draw();</script> 
	
	
    <!-- Card Template -->
    <template id="card-template">
        <div class="card" draggable="true">
            <h3 class="card-title"></h3>
            <!-- NEW: Metadata Display Area -->
            <div class="card-meta">
                <div class="card-created"><strong>Created:</strong> <span></span></div>
                <div class="card-status"><strong>Status:</strong> <span></span></div>
                <div class="card-priority"><strong>Priority:</strong> <span></span></div>
            </div>
            <!-- End Metadata -->
            <div class="card-content"></div>
            <div class="card-actions">
                <button class="edit-btn">Edit</button>
                <button class="delete-btn">Delete</button>
            </div>
        </div>
    </template>
	


    <!-- EasyMDE JS -->
    <script src="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js"></script>
    <!-- Marked JS (for rendering Markdown display) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

	<script src="MemoAI_CONFIG.js"></script>

    <script>
        // <<< START NEW FUNCTION: HIGHLIGHT CARD (GLOBAL SCOPE NEEDED FOR POPUP) >>>
        // Make this function globally accessible for the popup window's onclick handler
        function highlightCard(cardId) {
            const cardContainer = document.getElementById('card-container'); // Get container inside function
            if (!cardContainer) return;

            // Remove existing highlights first
            cardContainer.querySelectorAll('.card.highlighted-card').forEach(card => {
                card.classList.remove('highlighted-card');
            });

            const cardElement = cardContainer.querySelector(`.card[data-id="${cardId}"]`);
            if (cardElement) {
                console.log(`Highlighting card ID: ${cardId}`);
                cardElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                cardElement.classList.add('highlighted-card');

                // Optional: Remove highlight after a delay
                setTimeout(() => {
                    if (cardElement.classList.contains('highlighted-card')) {
                         cardElement.classList.remove('highlighted-card');
                    }
                }, 3000); // Keep highlight for 3 seconds
            } else {
                console.warn(`Card ID ${cardId} not found in the main window to highlight.`);
                // Optionally alert the user if the card is no longer visible (e.g., due to filter change)
                // alert(`Note with ID ${cardId} is not currently visible.`);
            }
        }
        // <<< END NEW FUNCTION: HIGHLIGHT CARD >>>


        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Variables ---
            const dbName = 'MarkdownCardsDB';
            const storeName = 'cards';
            let db;
            let easyMDEInstance = null;
            let draggedItem = null;
			let dropTargetElement = null; // NEW: To store the element to insert before
            let originalCardDataBeforeEdit = null; // To store original data before editing
            let summaryWindow = null; // <<< NEW: Keep track of the summary popup window

            // --- DOM Elements ---
            const cardContainer = document.getElementById('card-container');
            const addCardBtn = document.getElementById('add-card-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtnLabel = document.querySelector('.file-upload-label');
            const importFileInput = document.getElementById('import-file');
            const cardTemplate = document.getElementById('card-template');
            const showOpenOnlyCheckbox = document.getElementById('show-open-only-checkbox');
            const aiSearchInput = document.getElementById('ai-search-input');
            const aiSearchBtn = document.getElementById('ai-search-btn');
            const aiSummarizeBtn = document.getElementById('ai-summarize-btn'); // <<< NEW: Summarize button
            const aiStatus = document.getElementById('ai-status');
            const editModal = document.getElementById('edit-modal');
            const modalTitle = document.getElementById('modal-title');
            const editForm = document.getElementById('edit-form');
            const editIdInput = document.getElementById('edit-id');
            const editTitleInput = document.getElementById('edit-title');
            const editMarkdownTextarea = document.getElementById('edit-markdown');
            const cancelEditBtn = document.getElementById('cancel-edit-btn');
            const saveCardBtn = document.getElementById('save-card-btn');
            const editCreatedAtInput = document.getElementById('edit-created-at');
            const editStatusSelect = document.getElementById('edit-status');
            const editPrioritySelect = document.getElementById('edit-priority');
            const dropLineIndicator = cardContainer.querySelector('.drop-line-indicator'); // Get the line element

            // --- AI Configuration ---
            const GEMINI_API_KEY = CONFIG.GEMINI_API_KEY;
            const GEMINI_MODEL = CONFIG.GEMINI_MODEL;
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
            let allCardsCache = []; // Cache for filtering


            // --- IndexedDB Functions ---
            // ... (keep existing IndexedDB functions: openDb, getStore, addCardDb, getAllCardsDb, getCardDb, updateCardDb, deleteCardDb, clearAllCardsDb) ...
            function openDb() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(dbName, 1); // Version 1

                    request.onupgradeneeded = (event) => {
                        const dbInstance = event.target.result;
                        if (!dbInstance.objectStoreNames.contains(storeName)) {
                             const store = dbInstance.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
                            store.createIndex('order', 'order', { unique: false });
                            // Optional: Add indexes for status, priority, createdAt if needed later
                            console.log('IndexedDB store created.');
                        }
                    };

                    request.onsuccess = (event) => {
                        db = event.target.result;
                        console.log('IndexedDB opened successfully.');
                        resolve(db);
                    };

                    request.onerror = (event) => {
                        console.error('IndexedDB error:', event.target.errorCode);
                        reject(event.target.error);
                    };
                });
            }

            function getStore(mode = 'readonly') {
                if (!db) {
                    console.error("DB not initialized!");
                    // Attempt to reopen if not initialized (simple recovery)
                    return openDb().then(dbInstance => dbInstance.transaction(storeName, mode).objectStore(storeName));
                }
                 return Promise.resolve(db.transaction(storeName, mode).objectStore(storeName));
            }

            async function addCardDb(card) {
                const cardToAdd = {
                    title: card.title || 'Untitled',
                    text: card.text || '',
                    order: typeof card.order === 'number' ? card.order : 0,
                    createdAt: card.createdAt || new Date().toISOString(),
                    status: card.status || 'Open',
                    priority: card.priority || 'Medium'
                };
                const store = await getStore('readwrite');
                return new Promise((resolve, reject) => {
                    const request = store.add(cardToAdd);
                    request.onsuccess = event => resolve(event.target.result);
                    request.onerror = event => reject(event.target.error);
                });
            }

             async function getAllCardsDb() {
                const store = await getStore('readonly');
                const index = store.index('order');
                return new Promise((resolve, reject) => {
                    const request = index.getAll();
                    request.onsuccess = event => {
                        const sortedCards = event.target.result.sort((a, b) => (a.order || 0) - (b.order || 0));
                        allCardsCache = sortedCards; // Update cache
                        resolve(sortedCards);
                    }
                    request.onerror = event => reject(event.target.error);
                });
            }

             async function getCardDb(id) {
                 id = Number(id);
                 if (isNaN(id)) return Promise.reject("Invalid ID format");

                const store = await getStore('readonly');
                return new Promise((resolve, reject) => {
                    const request = store.get(id);
                    request.onsuccess = event => resolve(event.target.result);
                    request.onerror = event => reject(event.target.error);
                });
            }

             async function updateCardDb(card) {
                if (!card || typeof card.id === 'undefined') {
                     return Promise.reject("Invalid card data for update: Missing ID");
                }
                card.id = Number(card.id);
                if (isNaN(card.id)) return Promise.reject("Invalid ID format for update");

                 const cardToUpdate = {
                    ...card,
                    createdAt: card.createdAt || new Date().toISOString(),
                    status: card.status || 'Open',
                    priority: card.priority || 'Medium'
                 };

                const store = await getStore('readwrite');
                return new Promise((resolve, reject) => {
                    const request = store.put(cardToUpdate);
                    request.onsuccess = event => resolve(event.target.result);
                    request.onerror = event => reject(event.target.error);
                });
            }

             async function deleteCardDb(id) {
                 id = Number(id);
                 if (isNaN(id)) return Promise.reject("Invalid ID format for delete");

                 const store = await getStore('readwrite');
                return new Promise((resolve, reject) => {
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = event => reject(event.target.error);
                });
            }

            async function clearAllCardsDb() {
                const store = await getStore('readwrite');
                return new Promise((resolve, reject) => {
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = event => reject(event.target.error);
                });
            }


            // --- Helper Functions ---
            // ... (keep existing helpers: formatDisplayDate, formatInputDateTimeLocal) ...
            function formatDisplayDate(isoString) {
                if (!isoString) return 'N/A';
                try {
                    const date = new Date(isoString);
                    if (isNaN(date.getTime())) return 'Invalid Date';
                    return date.toLocaleString(undefined, {
                        year: 'numeric', month: 'numeric', day: 'numeric',
                        hour: 'numeric', minute: '2-digit'
                    });
                } catch (e) {
                    console.error("Error formatting date:", isoString, e);
                    return 'Error';
                }
            }

            function formatInputDateTimeLocal(dateSource) {
                if (!dateSource) return "";
                try {
                    const date = (dateSource instanceof Date) ? dateSource : new Date(dateSource);
                    if (isNaN(date.getTime())) return "";
                    const pad = (num) => num.toString().padStart(2, '0');
                    const year = date.getFullYear();
                    const month = pad(date.getMonth() + 1);
                    const day = pad(date.getDate());
                    const hours = pad(date.getHours());
                    const minutes = pad(date.getMinutes());
                    return `${year}-${month}-${day}T${hours}:${minutes}`;
                } catch (e) {
                    console.error("Error formatting for datetime-local:", dateSource, e);
                    return "";
                }
            }


            // --- Card Rendering ---
            // ... (keep existing renderCard function) ...
             function renderCard(cardData) {
                const cardClone = cardTemplate.content.cloneNode(true);
                const cardElement = cardClone.querySelector('.card');
                const titleElement = cardElement.querySelector('.card-title');
                const contentElement = cardElement.querySelector('.card-content');
                const editBtn = cardElement.querySelector('.edit-btn');
                const deleteBtn = cardElement.querySelector('.delete-btn');
                const createdAtEl = cardElement.querySelector('.card-created span');
                const statusEl = cardElement.querySelector('.card-status span');
                const priorityEl = cardElement.querySelector('.card-priority span');

                cardElement.dataset.id = cardData.id;
                // Use CSS variable for order, mirroring DB value
                cardElement.style.setProperty('--order', cardData.order || 0);
                titleElement.textContent = cardData.title || 'Untitled';

                // Populate Metadata
                createdAtEl.textContent = formatDisplayDate(cardData.createdAt);
                const status = cardData.status || 'Open';
                statusEl.textContent = status;
                if (status.toLowerCase() === 'closed') {
                    cardElement.classList.add('status-closed');
                } else {
                     cardElement.classList.remove('status-closed');
                }

                const priority = (cardData.priority || 'Medium').toLowerCase();
				priorityEl.innerHTML = `<span class="priority-label priority-${priority}">${cardData.priority || 'Medium'}</span>`;

                // Render Markdown content
                if (window.marked && typeof window.marked.parse === 'function') {
                    marked.use({ breaks: true, gfm: true });
                    contentElement.innerHTML = marked.parse(cardData.text || '');
                } else {
                    console.error("Marked.js not loaded correctly!");
                    contentElement.textContent = cardData.text || ''; // Fallback
                }

                // Add event listeners
                editBtn.addEventListener('click', () => handleEdit(cardData.id));
                deleteBtn.addEventListener('click', () => handleDelete(cardData.id));

				// Double-click to edit
				cardElement.addEventListener('dblclick', () => handleEdit(cardData.id));

                // Drag and Drop listeners for the card itself
                cardElement.addEventListener('dragstart', handleDragStart);
                cardElement.addEventListener('dragend', handleDragEnd);
                // Removed dragenter/dragleave from individual cards as container handles it

                cardContainer.appendChild(cardElement);
                return cardElement;
            }


            // --- Card Loading & Filtering ---
            // ... (keep existing loadCards function) ...
			async function loadCards(filterIds = null) {
                // Clear only cards, keep the indicator line element
                Array.from(cardContainer.querySelectorAll('.card')).forEach(card => card.remove());

                try {
                    let cardsToRender = allCardsCache.length > 0 && filterIds === null ? allCardsCache : await getAllCardsDb();

                    // Apply "Show Only Open" filter
                    if (showOpenOnlyCheckbox.checked) {
                        cardsToRender = cardsToRender.filter(card => card.status === 'Open');
                    }

                    let finalFilteredCards = cardsToRender;

                    if (filterIds !== null && Array.isArray(filterIds)) {
                        // Filter based on AI search IDs
                        const filterIdSet = new Set(filterIds.map(id => Number(id)));
                        finalFilteredCards = cardsToRender.filter(card => filterIdSet.has(card.id));

                        // Update status message based on AI results combined with checkbox filter
                         if(finalFilteredCards.length === 0 && filterIds.length > 0) {
                           aiStatus.textContent = `AI found ${filterIds.length} potential match(es), but none are visible${showOpenOnlyCheckbox.checked ? " (with 'Open Only' checked)" : ""}.`;
                         } else if (finalFilteredCards.length === 0 && filterIds.length === 0){
                           aiStatus.textContent = `No cards matched your query${showOpenOnlyCheckbox.checked ? " (within currently visible cards)" : ""}.`;
                         } else {
                           aiStatus.textContent = `Showing ${finalFilteredCards.length} matching card(s)${showOpenOnlyCheckbox.checked ? " (within 'Open Only' cards)" : ""}.`;
                         }
                    } else if (filterIds === null) {
                        // Clear status if not an AI filter result
                         aiStatus.textContent = '';
                    }

                    // Render the final list
                    if (finalFilteredCards.length === 0) {
                         const message = filterIds !== null
                             ? `No cards match the current filters${showOpenOnlyCheckbox.checked ? ' (Open Only + AI Search)' : ' (AI Search)'}.`
                             : `No cards to display${showOpenOnlyCheckbox.checked ? ' (with status Open)' : ''}. Add one!`;
                         const p = document.createElement('p');
                         p.style.color = '#666';
                         p.textContent = message;
                         cardContainer.appendChild(p); // Append message instead of setting innerHTML
                    } else {
                        finalFilteredCards.forEach(card => renderCard(card));
                    }
                } catch (error) {
                    console.error("Error loading/filtering cards:", error);
                    alert("Could not load cards from the database.");
                     aiStatus.textContent = 'Error loading cards.';
                }
            }

            // --- Modal Handling ---
            // ... (keep existing modal functions: openEditModal, hasUnsavedChanges, requestCloseModal, closeEditModal, handleSaveCard, handleEdit, handleDelete) ...
             function openEditModal(card = null) {
                originalCardDataBeforeEdit = null;

                if (easyMDEInstance) {
                    easyMDEInstance.toTextArea();
                    easyMDEInstance = null;
                }

                if (card) { // Editing existing card
                    modalTitle.textContent = "Edit Card";
                    editIdInput.value = card.id;
                    editTitleInput.value = card.title || '';
                    editMarkdownTextarea.value = card.text || '';
                    editCreatedAtInput.value = formatInputDateTimeLocal(card.createdAt || new Date());
                    editStatusSelect.value = card.status || 'Open';
                    editPrioritySelect.value = card.priority || 'Medium';
                    originalCardDataBeforeEdit = { // Store original values
                        id: card.id,
                        title: card.title || '',
                        text: card.text || '',
                        createdAt: formatInputDateTimeLocal(card.createdAt || new Date()),
                        status: card.status || 'Open',
                        priority: card.priority || 'Medium'
                    };
                } else { // Adding new card
                    modalTitle.textContent = "Add New Card";
                    editIdInput.value = '';
                    editForm.reset(); // Reset form to defaults
                    editCreatedAtInput.value = formatInputDateTimeLocal(new Date()); // Set current date
                    editStatusSelect.value = 'Open';
                    editPrioritySelect.value = 'Medium';
                    originalCardDataBeforeEdit = { isNew: true };
                }

                editModal.style.display = 'block';
                try {
                    easyMDEInstance = new EasyMDE({
                        element: editMarkdownTextarea,
						spellChecker: false,
                        status: false,
						placeholder: "Start typing to edit...",
                        renderingConfig: { singleLineBreaks: true, codeSyntaxHighlighting: true },
                        toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "image", "table", "|", "preview", "side-by-side", "fullscreen", "|", "guide"],
                    });
                } catch (error) {
                     console.error("Failed to initialize EasyMDE:", error);
                     alert("Error initializing the markdown editor. Please check the console.");
                }
                editTitleInput.focus();
            }

            function hasUnsavedChanges() {
                if (!originalCardDataBeforeEdit) return false;

                const currentTitle = editTitleInput.value.trim();
                const currentText = easyMDEInstance ? easyMDEInstance.value() : editMarkdownTextarea.value;
                const currentCreatedAt = editCreatedAtInput.value;
                const currentStatus = editStatusSelect.value;
                const currentPriority = editPrioritySelect.value;

                if (originalCardDataBeforeEdit.isNew) {
                    // Check if anything significant was entered for a new card
                    return currentTitle !== '' || currentText.trim() !== '' ||
                           currentStatus !== 'Open' || currentPriority !== 'Medium'; // Check if defaults changed
                } else {
                    // Compare with stored original values for existing card
                    return currentTitle !== originalCardDataBeforeEdit.title ||
                           currentText !== originalCardDataBeforeEdit.text ||
                           currentCreatedAt !== originalCardDataBeforeEdit.createdAt ||
                           currentStatus !== originalCardDataBeforeEdit.status ||
                           currentPriority !== originalCardDataBeforeEdit.priority;
                }
            }

            function requestCloseModal() {
                if (hasUnsavedChanges()) {
                    if (confirm("You have unsaved changes. Discard them?")) {
                        closeEditModal();
                    }
                } else {
                    closeEditModal();
                }
            }

            function closeEditModal() {
                if (easyMDEInstance) {
                    try { easyMDEInstance.toTextArea(); } catch (e) { console.error("Error cleaning up EasyMDE:", e); }
                    easyMDEInstance = null;
                }
                editModal.style.display = 'none';
                editForm.reset(); // Reset form fields
                originalCardDataBeforeEdit = null; // Clear original data state
            }

            async function handleSaveCard(event) {
                event.preventDefault();
                saveCardBtn.disabled = true;
                saveCardBtn.textContent = 'Saving...';

                const id = editIdInput.value;
                const title = editTitleInput.value.trim();
                const text = easyMDEInstance ? easyMDEInstance.value() : editMarkdownTextarea.value;
                let createdAtISO = new Date().toISOString(); // Default to now
                try {
                    if (editCreatedAtInput.value) {
                         createdAtISO = new Date(editCreatedAtInput.value).toISOString();
                    }
                } catch (e) { console.error("Invalid date from input, using current time.", e) }
                const status = editStatusSelect.value;
                const priority = editPrioritySelect.value;

                try {
                     if (id) { // Update existing card
                        const existingCard = await getCardDb(id);
                        if (!existingCard) throw new Error(`Card with ID ${id} not found for update.`);
                        const cardData = {
                             id: Number(id), title, text, order: existingCard.order, // Keep existing order
                             createdAt: createdAtISO, status, priority
                        };
                        await updateCardDb(cardData);
                    } else { // Add new card
                        const cards = await getAllCardsDb();
                        const maxOrder = cards.reduce((max, card) => Math.max(max, card.order || 0), -1);
                        const cardData = {
                            title, text, order: maxOrder + 1, // Add to end
                            createdAt: createdAtISO, status, priority
                         };
                        await addCardDb(cardData);
                    }
                    closeEditModal(); // Close after successful save
                    allCardsCache = []; // Invalidate cache
                    await loadCards(); // Reload cards
                } catch (error) {
                    console.error("Error saving card:", error);
                    alert(`Failed to save card: ${error.message}`);
                } finally {
                    saveCardBtn.disabled = false;
                    saveCardBtn.textContent = 'Save Card';
                }
            }

            async function handleEdit(id) {
                try {
                    const card = await getCardDb(id);
                    if (card) {
                        openEditModal(card);
                    } else {
                        console.error("Card not found for editing:", id);
                        alert("Could not find the card to edit.");
                        await loadCards(); // Reload to ensure consistency
                    }
                } catch (error) {
                    console.error("Error fetching card for edit:", error);
                    alert("Failed to load card data for editing.");
                }
            }

            async function handleDelete(id) {
                if (confirm('Are you sure you want to delete this card?')) {
                    try {
                        await deleteCardDb(id);
                        console.log("Card deleted:", id);
                        // Remove element directly instead of full reload for better UX
                        const cardElement = cardContainer.querySelector(`.card[data-id="${id}"]`);
                        if (cardElement) cardElement.remove();
                        allCardsCache = []; // Invalidate cache as order/content changed
                        // No loadCards() needed unless order needs recalculation, handled by drop anyway
                    } catch (error) {
                        console.error("Error deleting card:", error);
                        alert("Failed to delete card.");
                    }
                }
            }


            // --- Import/Export ---
            // ... (keep existing handleExport and handleImport functions) ...
             async function handleExport() {
                try {
                    const cards = await getAllCardsDb();
                    const cardsToExport = cards.map(c => ({ // Ensure all needed fields are present
                         id: c.id, title: c.title, text: c.text, order: c.order,
                         createdAt: c.createdAt, status: c.status, priority: c.priority
                    }));
                    const dataStr = JSON.stringify(cardsToExport, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = 'cards-export.json';
                    document.body.appendChild(a); a.click();
                    document.body.removeChild(a); URL.revokeObjectURL(url);
                    console.log("Cards exported.");
                } catch (error) {
                    console.error("Error exporting cards:", error);
                    alert("Failed to export cards.");
                }
            }

            function handleImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const importedCards = JSON.parse(e.target.result);
                        if (!Array.isArray(importedCards)) throw new Error("Imported file is not a valid card array.");

                        // Basic validation
                        const isValid = importedCards.every(card =>
                            typeof card === 'object' && card !== null &&
                            typeof card.title === 'string' && typeof card.text === 'string' && typeof card.order === 'number'
                        );
                        if (!isValid) throw new Error("Imported data has invalid structure (missing title, text, or order).");

                        if (confirm('Importing will replace all current cards. Are you sure?')) {
                            await clearAllCardsDb();
                            for (const card of importedCards) {
                                const { id, ...cardData } = card; // Remove old ID
                                await addCardDb(cardData); // Let addCardDb handle defaults
                            }
                            console.log("Cards imported successfully.");
							allCardsCache = []; // Clear cache after import
                            await loadCards(); // Reload to display
                        }
                    } catch (error) {
                        console.error("Error importing cards:", error);
                        alert(`Failed to import cards: ${error.message}`);
                    } finally {
                        importFileInput.value = null; // Reset file input
                    }
                };
                reader.onerror = (error) => {
                     console.error("Error reading file:", error);
                     alert("Failed to read the import file.");
                     importFileInput.value = null;
                };
                reader.readAsText(file);
            }


             // --- Drag and Drop Logic ---
             // ... (keep existing drag/drop functions: handleDragStart, handleDragEnd, handleDragOver, handleDragLeaveContainer, handleDrop, getDragAfterElement, showDropLineIndicator, hideDropLineIndicator, updateCardOrderInDb) ...
             function handleDragStart(e) {
				 draggedItem = e.target; // The card being dragged
                 setTimeout(() => { // Apply dragging style slightly after drag starts
                     if(draggedItem) draggedItem.classList.add('dragging');
                 }, 0);
                 e.dataTransfer.effectAllowed = 'move';
                 e.dataTransfer.setData('text/plain', draggedItem.dataset.id); // Store ID for reference
                 // Do not hide the line here, dragover will handle it
             }

			function handleDragEnd(e) {
				if (draggedItem && draggedItem.classList.contains('dragging')) {
					draggedItem.classList.remove('dragging');
				}
				hideDropLineIndicator(); // Hide the line when dragging stops
				draggedItem = null;
				dropTargetElement = null; // *** RESET stored target on drag end ***
			}

             function handleDragOver(e) {
				e.preventDefault();
				e.dataTransfer.dropEffect = 'move';

				const container = e.currentTarget;
				// Calculate the target element based on current mouse position
				const afterElement = getDragAfterElement(container, e.clientX, e.clientY);

				// *** STORE the calculated target ***
				dropTargetElement = afterElement;

				// Show the indicator based on the *stored* target
				showDropLineIndicator(container, dropTargetElement);
			}

			function handleDragLeaveContainer(e) {
				 // Hide the line only if the mouse truly leaves the container boundary
				 if (!e.currentTarget.contains(e.relatedTarget)) {
					 hideDropLineIndicator();
					 dropTargetElement = null; // *** RESET stored target on leaving container ***
				 }
			 }

			async function handleDrop(e) {
				e.preventDefault();

				// *** USE the stored target element ***
				const afterElement = dropTargetElement;

				// Reset the stored target and hide the indicator immediately
				dropTargetElement = null;
				hideDropLineIndicator();

				if (!draggedItem) return; // Check if we are actually dragging something

				const container = e.currentTarget; // Get container from the event

				// Move the draggedItem in the DOM using the stored afterElement
				if (afterElement === null) { // Check for null explicitly
					container.appendChild(draggedItem);
					console.log(`Dropping card ${draggedItem.dataset.id} at the end`);
				} else {
					container.insertBefore(draggedItem, afterElement);
					console.log(`Dropping card ${draggedItem.dataset.id} before card ${afterElement.dataset.id}`);
				}

				// Update Order in IndexedDB (This part remains the same)
				await updateCardOrderInDb();

				// Ensure dragging class is removed (already handled by dragend)
				// The draggedItem variable itself will be cleared in handleDragEnd
			}

			// Helper to calculate the element *before* which the dragged item should be placed
			function getDragAfterElement(container, x, y) {
				const draggableElements = [...container.querySelectorAll('.card:not(.dragging)')];

                if (draggableElements.length === 0) {
                    return null;
                }

				let closest = {
					distanceSq: Number.POSITIVE_INFINITY,
					element: null
				};

				draggableElements.forEach(child => {
					const box = child.getBoundingClientRect();
					const centerX = box.left + box.width / 2;
					const centerY = box.top + box.height / 2;
					const distanceSq = Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2);

					if (distanceSq < closest.distanceSq) {
						closest.distanceSq = distanceSq;
						closest.element = child;
					}
				});


                const closestElement = closest.element;

				// Step 2: Decide where to insert relative to the closest element
				if (closestElement) {
					const box = closestElement.getBoundingClientRect();
					const midpointX = box.left + box.width / 2;

					if (x < midpointX) {
						// Cursor is LEFT half -> insert BEFORE closestElement
						return closestElement;
					} else {
						// Cursor is RIGHT half -> insert AFTER closestElement (before its next sibling)
						return closestElement.nextElementSibling;
					}
				} else {
                    // Fallback if no closest element found
					return null;
				}
			}

            function showDropLineIndicator(container, afterElement) {
                if (!dropLineIndicator) return;

                const containerRect = container.getBoundingClientRect();
                const containerStyle = window.getComputedStyle(container);
                const containerGap = parseInt(containerStyle.gap || '20', 10);
                const indicatorWidth = parseInt(window.getComputedStyle(dropLineIndicator).width || '3', 10);

                let lineLeft = 0;
                let lineTop = 0;
                let lineHeight = 0;

                // Determine the reference element for vertical positioning
                // If dropping before an element, use that element.
                // If dropping at the end (afterElement is null), use the last element.
                const refElement = afterElement || container.querySelector('.card:not(.dragging):last-of-type');

                if (refElement) {
                    // Base vertical position on the reference element
                    const refRect = refElement.getBoundingClientRect();
                    const refStyle = window.getComputedStyle(refElement);
                     // offsetTop is relative to the container
                    lineTop = refElement.offsetTop;
                    lineHeight = refElement.offsetHeight;

                    // --- Horizontal Calculation (remains similar) ---
                    if (afterElement) {
                        // Calculate position to the left of the 'afterElement'
                        const afterRect = afterElement.getBoundingClientRect();
                        // Position line in the middle of the gap *before* this element
                        lineLeft = afterElement.offsetLeft - (containerGap / 2) - (indicatorWidth / 2);

                    } else {
                        // afterElement is null, means drop at the end. Position after the last element (refElement).
                        const lastRect = refElement.getBoundingClientRect(); // refElement is the last card here
                        // Position line in the middle of the gap *after* the last element
                        lineLeft = refElement.offsetLeft + refElement.offsetWidth + (containerGap / 2) - (indicatorWidth / 2);
                    }

                } else {
                    // Container is empty or only contains the dragged element
                    lineTop = parseInt(containerStyle.paddingTop || '10', 10);
                    // Try to approximate a card height or use a fixed value
                    lineHeight = 100; // Default height if no cards
                    // Position at the start of the container
                    lineLeft = parseInt(containerStyle.paddingLeft || '10', 10);
                }


                // Apply styles to position and show the line
                dropLineIndicator.style.left = `${Math.max(0, lineLeft)}px`; // Ensure not negative
                dropLineIndicator.style.top = `${lineTop}px`;
                dropLineIndicator.style.height = `${lineHeight}px`;
                dropLineIndicator.style.display = 'block';
            }

            function hideDropLineIndicator() {
                 if (dropLineIndicator) {
                     dropLineIndicator.style.display = 'none';
                 }
            }


			async function updateCardOrderInDb() {
                // *** CORRECTED SELECTOR ***
                // Get ALL card elements in their current DOM order AFTER the drop,
                // including the one that was just dropped.
                const cardsInNewOrder = Array.from(cardContainer.querySelectorAll('.card'));
                //console.log(`Updating order for ${cardsInNewOrder.length} cards based on current DOM sequence.`); // Debug log

                // Create promises to update each card based on its new DOM index
                const updatePromises = cardsInNewOrder.map(async (cardEl, index) => {
                    const cardId = Number(cardEl.dataset.id);
                    try {
                        // Fetch the card data
                        const cardData = await getCardDb(cardId);
                        if (cardData) {
                            // *** UNCONDITIONAL UPDATE ***
                            // Set the card's order to its current index in the DOM list.
                            //console.log(`  Updating Card ID ${cardId}: Setting order to ${index} (was ${cardData.order})`); // Log
                            cardData.order = index;
                            return updateCardDb(cardData); // Return the promise to update this card
                        } else {
                            console.warn("Card data not found in DB for ID during reorder:", cardId);
                            return Promise.resolve();
                        }
                    } catch (error) {
                        console.error(`Error processing card ID ${cardId} during reorder:`, error);
                        return Promise.reject(error);
                    }
                });

                // Wait for all database updates to complete
                try {
                    await Promise.all(updatePromises);
                    console.log("Card order update process completed successfully in IndexedDB.");

                    // Update the data-order attribute and CSS variable on the DOM elements
                    cardsInNewOrder.forEach((cardEl, index) => {
                        cardEl.dataset.order = index;
                        cardEl.style.setProperty('--order', index);
                    });

                    // Invalidate the cache
                    allCardsCache = [];
                    console.log("Local card cache cleared due to reordering.");

                } catch (error) {
                    console.error("One or more errors occurred during card order update in DB:", error);
                    alert("Error saving the new card order. The display might be inconsistent. Please refresh.");
                    await loadCards(); // Reload on error
                }
            }


			// --- AI Search Functions ---

            function showLoading(isLoading, actionType = 'Search') { // <<< Modified for different actions
                const isSearch = actionType === 'Search';
                const buttonToModify = isSearch ? aiSearchBtn : aiSummarizeBtn;
                const buttonText = isSearch ? 'AI Search' : 'AI Summarize';
                const loadingText = isSearch ? 'Searching...' : 'Summarizing...';
                const statusText = isSearch ? 'Searching with AI...' : 'Summarizing with AI...';

                // Disable both buttons during any AI action
                aiSearchBtn.disabled = isLoading;
                aiSummarizeBtn.disabled = isLoading;

                buttonToModify.textContent = isLoading ? loadingText : buttonText;
                aiStatus.textContent = isLoading ? statusText : aiStatus.textContent; // Keep existing status otherwise
            }

            // Existing callGeminiApi for search remains the same
             async function callGeminiApi(query, cardsData) {
                 if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY_HERE') {
                     throw new Error("Gemini API key is missing or placeholder. Please add it to MemoAI_CONFIG.js.");
                 }
                 if (cardsData.length === 0) {
                    console.log("No cards provided to Gemini for search.");
                    return []; // No point calling API if no cards match initial filter
                 }

                const cardsJsonString = JSON.stringify(cardsData.map(c => ({ // Send only relevant fields
                    id: c.id, title: c.title, status: c.status, priority: c.priority, text: c.text.substring(0, 800) // Limit text length slightly more?
                })), null, 2);

                const prompt = `
Context:
You are searching through notes (cards). Below is a JSON array of cards filtered by the user (e.g., only 'Open' status might be included). Each card has an id, title, status, priority, and text content.

Card Data (currently visible to user):
${cardsJsonString}

User Query:
"${query}"

Task:
Analyze the user query and the provided card data. Identify which cards MATCH the query based on their fields (id, title, status, priority, text). Consider meaning and context.

Output Format:
Return ONLY a valid JSON array containing the integer \`id\`s of the matching cards from the provided list. Example: [1, 5, 12]
If no cards match, return an empty array: []
Do NOT include explanations or markdown formatting. Just the JSON array of IDs.
                `;

                try {
                    console.log("Calling Gemini API for Search...");
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { responseMimeType: "application/json" } // Request JSON directly
                        }),
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("Gemini API Error Response:", errorBody);
                        let detail = `API request failed with status ${response.status}: ${response.statusText}`;
                        try {
                             const errJson = JSON.parse(errorBody);
                             detail = errJson.error?.message || detail;
                        } catch {}
                         if (response.status === 400 && detail.includes("API key not valid")) {
                              throw new Error("Invalid Gemini API Key. Check MemoAI_CONFIG.js.");
                         }
                          if (response.status === 403 && detail.includes("permission")) {
                            throw new Error("API Key is likely missing permissions for the Generative Language API. Enable it in Google Cloud Console.");
                         }
                         if (response.status === 429) {
                              throw new Error("AI Search quota likely exceeded. Try again later.");
                         }
                        throw new Error(detail);
                    }

                    const data = await response.json();
                    console.log("Gemini API Raw Response (Search):", JSON.stringify(data, null, 2)); // Debugging

                    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        let responseText = data.candidates[0].content.parts[0].text.trim();
                        // Clean potential markdown fences (optional, as mimeType should prevent)
                        // if (responseText.startsWith('```json')) responseText = responseText.substring(7, responseText.length - 3).trim();
                        // else if (responseText.startsWith('```')) responseText = responseText.substring(3, responseText.length - 3).trim();

                        try {
                             const result = JSON.parse(responseText);
                             if (Array.isArray(result) && result.every(item => typeof item === 'number')) {
                                 return result; // Success! Array of IDs.
                             } else {
                                 throw new Error("AI response was not a JSON array of numbers.");
                             }
                        } catch(parseError) {
                             console.error("Failed to parse Gemini JSON (Search):", parseError, "Raw text:", responseText);
                             throw new Error("AI response was not valid JSON.");
                        }
                    } else if (data.promptFeedback?.blockReason) {
                         throw new Error(`AI request blocked: ${data.promptFeedback.blockReason}. Modify query or safety settings.`);
                     } else if (!data.candidates || data.candidates.length === 0){
                        // Handle cases where the model returns no candidates (e.g., content filter)
                        const blockReason = data.promptFeedback?.blockReason || 'Unknown reason (possibly content safety)';
                        const safetyRatings = data.promptFeedback?.safetyRatings ? JSON.stringify(data.promptFeedback.safetyRatings) : 'N/A';
                         console.warn("Gemini returned no candidates. Block Reason:", blockReason, "Safety Ratings:", safetyRatings);
                        throw new Error(`AI response was empty. Block Reason: ${blockReason}.`);
                     }
                     else {
                         throw new Error("Unexpected AI response structure (Search).");
                    }
                } catch (error) {
                    console.error("Error calling Gemini API (Search):", error);
                    throw error; // Re-throw
                }
            }

            async function performAiSearch() {
                const query = aiSearchInput.value.trim();
                if (!query) {
                    await loadCards(null); // Clear filter if query is empty
                    return;
                }
                if (!db) { aiStatus.textContent = 'Database not ready.'; return; }

                showLoading(true, 'Search');
                try {
                    // Fetch *all* cards first to ensure cache is up-to-date
                    await getAllCardsDb(); // This updates allCardsCache

                    // Filter based on checkbox *before* sending to AI
                    let cardsToSearch = allCardsCache;
                    if (showOpenOnlyCheckbox.checked) {
                        cardsToSearch = allCardsCache.filter(card => card.status === 'Open');
                        if (cardsToSearch.length === 0) {
                             aiStatus.textContent = "No 'Open' cards to search with AI.";
                             await loadCards(null); // Show the 'no open cards' message
                             showLoading(false, 'Search');
                             return;
                        }
                    }

                    // Prepare data for AI (only the pre-filtered cards)
                    const cardsForAI = cardsToSearch.map(c => ({
                        id: c.id, title: c.title, createdAt: c.createdAt,
                        status: c.status, priority: c.priority, text: c.text
                    }));

                    const matchingIds = await callGeminiApi(query, cardsForAI);
                    console.log("AI Search Matched IDs (from visible set):", matchingIds);

                    // Reload/filter display based on AI results. loadCards will re-apply checkbox filter too.
                    await loadCards(matchingIds);

                } catch (error) {
                    console.error("AI Search failed:", error);
                    const message = error.message || "An unknown error occurred.";
                    alert(`AI Search Error: ${message}`);
                    aiStatus.textContent = `Search Error: ${message.length > 60 ? message.substring(0, 60)+'...' : message}`;
                    // Optionally revert to showing cards based on checkbox on error
                    // await loadCards(null);
                } finally {
                    showLoading(false, 'Search');
                }
            }

            // --- <<< NEW: AI Summarizer Functions >>> ---

            async function callGeminiApiForSummary(query, cardsData) {
                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY_HERE') {
                    throw new Error("Gemini API key is missing or placeholder. Please add it to MemoAI_CONFIG.js.");
                }
                if (cardsData.length === 0) {
                    console.log("No cards provided to Gemini for summary.");
                    return { summary: "No cards found to summarize based on the current filter.", references: [] };
                }

                // Limit text sent per card to keep prompt size reasonable
                const MAX_TEXT_LENGTH = 1000;
                const cardsJsonString = JSON.stringify(cardsData.map(c => ({
                    id: c.id,
                    title: c.title,
                    status: c.status, // Include status/priority as context
                    priority: c.priority,
                    text: c.text ? c.text.substring(0, MAX_TEXT_LENGTH) + (c.text.length > MAX_TEXT_LENGTH ? '...' : '') : ''
                })), null, 2);

                const prompt = `
Context:
You are an AI assistant summarizing notes (cards) based on a user query. Below is a JSON array of cards potentially relevant to the query. These cards might be pre-filtered by the user (e.g., only 'Open' status cards). Each card has an id, title, status, priority, and text content.

Card Data:
${cardsJsonString}

User Query:
"${query}"

Task:
1.  Carefully read the User Query and analyze the provided Card Data.
2.  Synthesize a concise summary based on the information in the cards that is relevant to the user's query. Focus on the key points and themes related to the query found across the notes.
3.  Identify the specific cards used to generate the summary. For each referenced card, provide its \`id\`, \`title\`, and a very brief (1-sentence max) reason why it was included in the summary context.
4.  Format the output STRICTLY as a single JSON object with two keys:
    *   \`summary\`: A string containing the generated summary in Markdown format.
    *   \`references\`: An array of objects, where each object has the following keys:
        *   \`id\`: The integer ID of the referenced card.
        *   \`title\`: The string title of the referenced card.
        *   \`reason\`: A brief string explaining the card's relevance to the summary.

Example Output JSON:
{
  "summary": "Based on the query about 'Project Alpha', the notes indicate that the *design phase* is complete (see 'Alpha Design Spec') and the team is currently working on *backend implementation* ('Alpha Backend Tasks'). There are some concerns about the timeline mentioned in the 'Meeting Notes'.",
  "references": [
    { "id": 5, "title": "Alpha Design Spec", "reason": "Provides details on the completed design phase." },
    { "id": 12, "title": "Alpha Backend Tasks", "reason": "Lists the current implementation tasks." },
    { "id": 8, "title": "Meeting Notes", "reason": "Mentions potential timeline issues." }
  ]
}

Important Constraints:
*   Return ONLY the JSON object. No introductory text, no explanations, no markdown code fences around the JSON.
*   Ensure the \`id\` in the references corresponds EXACTLY to an ID from the provided Card Data.
*   If no cards contain information relevant to the query, return a JSON object like this:
    { "summary": "No relevant information found in the provided notes for the query: '${query}'", "references": [] }
                `;

                try {
                    console.log("Calling Gemini API for Summary...");
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { responseMimeType: "application/json" } // Request JSON directly
                        }),
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("Gemini API Error Response (Summary):", errorBody);
                        let detail = `API request failed with status ${response.status}: ${response.statusText}`;
                        try { const errJson = JSON.parse(errorBody); detail = errJson.error?.message || detail; } catch {}
                         if (response.status === 400 && detail.includes("API key not valid")) {
                              throw new Error("Invalid Gemini API Key. Check MemoAI_CONFIG.js.");
                         }
                          if (response.status === 403 && detail.includes("permission")) {
                            throw new Error("API Key is likely missing permissions for the Generative Language API. Enable it in Google Cloud Console.");
                         }
                         if (response.status === 429) {
                              throw new Error("AI Summary quota likely exceeded. Try again later.");
                         }
                        throw new Error(detail);
                    }

                    const data = await response.json();
                     console.log("Gemini API Raw Response (Summary):", JSON.stringify(data, null, 2)); // Debugging

                    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        let responseText = data.candidates[0].content.parts[0].text.trim();
                         try {
                            const result = JSON.parse(responseText);
                            // Validate the structure
                            if (typeof result === 'object' && result !== null &&
                                typeof result.summary === 'string' &&
                                Array.isArray(result.references) &&
                                result.references.every(ref => typeof ref === 'object' && ref !== null && typeof ref.id === 'number' && typeof ref.title === 'string' && typeof ref.reason === 'string')
                            ) {
                                return result; // Success! Valid summary object.
                            } else {
                                console.error("Parsed JSON (Summary) has incorrect structure:", result);
                                throw new Error("AI response structure was invalid (missing summary/references or incorrect types).");
                            }
                        } catch (parseError) {
                            console.error("Failed to parse Gemini JSON (Summary):", parseError, "Raw text:", responseText);
                            throw new Error("AI response was not valid JSON.");
                        }
                    } else if (data.promptFeedback?.blockReason) {
                         throw new Error(`AI request blocked: ${data.promptFeedback.blockReason}. Modify query or safety settings.`);
                    } else if (!data.candidates || data.candidates.length === 0){
                        const blockReason = data.promptFeedback?.blockReason || 'Unknown reason (possibly content safety)';
                        const safetyRatings = data.promptFeedback?.safetyRatings ? JSON.stringify(data.promptFeedback.safetyRatings) : 'N/A';
                         console.warn("Gemini returned no candidates for summary. Block Reason:", blockReason, "Safety Ratings:", safetyRatings);
                        throw new Error(`AI response for summary was empty. Block Reason: ${blockReason}.`);
                     }
                    else {
                        throw new Error("Unexpected AI response structure (Summary).");
                    }
                } catch (error) {
                    console.error("Error calling Gemini API (Summary):", error);
                    throw error; // Re-throw
                }
            }

            function formatSummaryForPopup(summaryData) {
                if (!window.marked) {
                    console.error("Marked library not loaded. Cannot render Markdown.");
                    // Fallback to plain text or simple HTML
                     let fallbackHtml = `<h2>Summary</h2><p>${summaryData.summary.replace(/\n/g, '<br>')}</p><h2>References</h2>`;
                     if (summaryData.references && summaryData.references.length > 0) {
                         fallbackHtml += '<ul>';
                         summaryData.references.forEach(ref => {
                             fallbackHtml += `<li><a href="#" onclick="window.opener.highlightCard(${ref.id}); return false;">${ref.title || 'Untitled'}</a>: ${ref.reason}</li>`;
                         });
                         fallbackHtml += '</ul>';
                     } else {
                         fallbackHtml += '<p>No specific notes referenced.</p>';
                     }
                    return fallbackHtml;
                }

                marked.use({ breaks: true, gfm: true }); // Ensure options are set

                let markdownString = `## Summary\n\n${summaryData.summary}\n\n## References\n\n`;

                if (summaryData.references && summaryData.references.length > 0) {
                    summaryData.references.forEach(ref => {
                        // Escape title for use in HTML attribute and display
                        const escapedTitle = (ref.title || 'Untitled')
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#039;');
                        // Use javascript:void(0) or # for href, onclick handles the action
                        markdownString += `*   <a href="javascript:void(0)" onclick="window.opener.highlightCard(${ref.id}); return false;" title="Click to highlight note ID ${ref.id}">${escapedTitle}</a>: ${ref.reason}\n`;
                    });
                } else {
                    markdownString += "*No specific notes were cited for this summary.*";
                }

                return marked.parse(markdownString); // Return rendered HTML
            }

            function displaySummaryPopup(htmlContent, query) {
                const windowName = "MemoAISummaryWindow";
                const windowFeatures = "width=700,height=600,resizable=yes,scrollbars=yes"; // Slightly taller

                // Try to focus existing window first
                if (summaryWindow && !summaryWindow.closed) {
                    summaryWindow.focus();
                } else {
                    // Open the window *immediately* with about:blank, but we'll quickly overwrite it
                    summaryWindow = window.open("", windowName, windowFeatures);
                    if (!summaryWindow) {
                        alert("Popup blocked! Please allow popups for this site to see the summary.");
                        return; // Exit if popup failed to open
                    }
                    // Give the browser a tiny moment to establish the window handle before writing
                    // This *might* slightly reduce the flash of "about:blank" title in some browsers,
                    // but setting the <title> tag is the real solution for the final state.
                    // await new Promise(resolve => setTimeout(resolve, 10)); // Optional small delay
                }

                // *** CRITICAL FIX: Properly escape HTML entities for the title AND display ***
                const escapedQuery = query.replace(/&/g, '&')
                                          .replace(/</g, '<')
                                          .replace(/>/g, '>');
                const truncatedTitleQuery = escapedQuery.substring(0, 60) + (escapedQuery.length > 60 ? '...' : '');


                // --- Start writing the new document ---
                summaryWindow.document.open();
                summaryWindow.document.write(`
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>AI Summary: ${truncatedTitleQuery}</title>
                        <style>
                            /* === Modern Popup Styles === */
                            :root {
                                --bg-color: #f0f2f5; /* Light grey background */
                                --card-bg: #ffffff; /* White content card */
                                --text-color: #333;
                                --heading-color: #1a1a1a;
                                --link-color: #007bff;
                                --link-hover-color: #0056b3;
                                --border-color: #e9ecef; /* Lighter border */
                                --code-bg: #f8f9fa; /* Background for inline code */
                                --pre-bg: #f1f3f5;  /* Background for code blocks */
                                --pre-border: #dee2e6;
                                --shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Softer shadow */
                            }
                            body {
                                font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
                                margin: 0;
                                padding: 20px; /* Add padding around the card */
                                background-color: var(--bg-color);
                                color: var(--text-color);
                                line-height: 1.6;
                                font-size: 15px;
                            }
                            .summary-popup-content {
                                background-color: var(--card-bg);
                                border-radius: 10px; /* Slightly more rounded */
                                box-shadow: var(--shadow);
                                padding: 25px 30px; /* Increase padding */
                                border: 1px solid var(--border-color); /* Add subtle border */
                                max-width: 800px; /* Limit width for readability */
                                margin: 0 auto; /* Center if window is wider */
                            }
                            h1 {
                                font-size: 1.8em; /* Larger main title */
                                color: var(--heading-color);
                                margin-bottom: 15px; /* Space below H1 */
                                font-weight: 600;
                                border-bottom: none; /* Remove border if Marked adds one */
                                margin-top: 0;
                            }
                            /* Style for the "Summary" and "References" headings generated by Marked */
                            h2 {
                                font-size: 1.3em;
                                color: var(--heading-color);
                                border-bottom: 2px solid var(--border-color); /* Cleaner border */
                                padding-bottom: 0.4em;
                                margin-top: 2em; /* More space above sections */
                                margin-bottom: 1.2em;
                                font-weight: 600;
                            }
                            p {
                                margin: 0 0 1em 0; /* Consistent paragraph spacing */
                            }
                            p.query-display strong { /* Style the "Based on query:" part */
                                color: #555;
                                font-weight: 600;
                                margin-right: 5px;
                            }
                            hr {
                                border: 0;
                                height: 1px;
                                background-color: var(--border-color);
                                margin: 2em 0; /* More vertical space */
                            }
                            ul, ol {
                                margin: 1em 0 1.5em 0;
                                padding-left: 2em; /* Standard indent */
                            }
                            li {
                                margin-bottom: 0.8em; /* Slightly more space between list items */
                            }
                            /* Inline Code */
                            code {
                                background-color: var(--code-bg);
                                padding: 3px 6px;
                                border-radius: 4px;
                                font-family: Consolas, "Courier New", monospace;
                                font-size: 0.92em; /* Slightly smaller */
                                border: 1px solid var(--border-color);
                            }
                            /* Code Blocks */
                            pre {
                                background-color: var(--pre-bg);
                                border: 1px solid var(--pre-border);
                                padding: 12px 15px;
                                border-radius: 6px;
                                overflow-x: auto;
                                font-family: Consolas, "Courier New", monospace;
                                font-size: 0.92em;
                                margin: 1.5em 0;
                                line-height: 1.45;
                            }
                            pre code { /* Code inside pre should not have its own background/border */
                                background-color: transparent;
                                border: none;
                                padding: 0;
                                border-radius: 0;
                                font-size: inherit; /* Inherit size from pre */
                            }
                            blockquote {
                                border-left: 4px solid var(--link-color); /* Use accent color */
                                margin: 1.5em 0;
                                padding: 10px 20px;
                                color: #555;
                                background-color: #fdfdff; /* Very slightly different background */
                            }
                            a {
                                color: var(--link-color);
                                text-decoration: none;
                                cursor: pointer;
                                font-weight: 500;
                                transition: color 0.2s ease; /* Smooth hover */
                            }
                            a:hover {
                                text-decoration: underline;
                                color: var(--link-hover-color);
                            }
                            /* References List Specifics */
                            .references-list li {
                                /* You could add more specific styling here if needed */
                            }
                            .references-list li a {
                                margin-right: 8px; /* More space between link and reason */
                            }
                        </style>
                    </head>
                    <body>
                        <div class="summary-popup-content">
                            <h1>AI Summary</h1>
                            <p class="query-display"><strong>Based on query:</strong> ${escapedQuery}</p>
                            <hr>
                            ${htmlContent}
                            <!-- Add class to UL containing references if needed for specific styling -->
                            <script>
                                const refHeaders = Array.from(document.querySelectorAll('h2'));
                                const refList = refHeaders.find(h => h.textContent.trim().toLowerCase() === 'references')?.nextElementSibling;
                                if (refList && (refList.tagName === 'UL' || refList.tagName === 'OL')) {
                                    refList.classList.add('references-list');
                                }
                            </scr` + `ipt>
                        </div>
                    </body>
                    </html>
                `);
                // --- Finish writing ---
                summaryWindow.document.close();
            }


            async function performAiSummarize() {
                 const query = aiSearchInput.value.trim();
                 if (!query) {
                    alert("Please enter a query in the AI input box to generate a summary.");
                    aiSearchInput.focus();
                    return;
                 }
                if (!db) { aiStatus.textContent = 'Database not ready.'; return; }

                showLoading(true, 'Summarize');
                try {
                    // Fetch *all* cards first to ensure cache is up-to-date
                    await getAllCardsDb(); // This updates allCardsCache

                    // Filter based on checkbox *before* sending to AI
                    let cardsToSummarize = allCardsCache;
                    if (showOpenOnlyCheckbox.checked) {
                        cardsToSummarize = allCardsCache.filter(card => card.status === 'Open');
                        const statusMsg = "No 'Open' cards available to summarize for this query.";
                        if (cardsToSummarize.length === 0) {
                             aiStatus.textContent = statusMsg;
                             alert(statusMsg);
                             showLoading(false, 'Summarize');
                             return;
                        }
                    } else {
                        const statusMsg = "No cards available to summarize.";
                         if (cardsToSummarize.length === 0) {
                             aiStatus.textContent = statusMsg;
                             alert(statusMsg);
                              showLoading(false, 'Summarize');
                             return;
                        }
                    }

                    // Prepare data for AI (only the pre-filtered cards)
                    const cardsForAI = cardsToSummarize.map(c => ({
                        id: c.id, title: c.title, createdAt: c.createdAt,
                        status: c.status, priority: c.priority, text: c.text
                    }));

                    const summaryData = await callGeminiApiForSummary(query, cardsForAI);
                    console.log("AI Summary Data:", summaryData);

                    // Format and display in popup
                    const popupHtml = formatSummaryForPopup(summaryData);
                    displaySummaryPopup(popupHtml, query);
                    aiStatus.textContent = `Summary generated for query: "${query.substring(0,30)}..."`;


                } catch (error) {
                    console.error("AI Summarize failed:", error);
                    const message = error.message || "An unknown error occurred.";
                    alert(`AI Summarize Error: ${message}`);
                    aiStatus.textContent = `Summarize Error: ${message.length > 60 ? message.substring(0, 60)+'...' : message}`;
                } finally {
                    showLoading(false, 'Summarize');
                }
            }

            // --- <<< END: AI Summarizer Functions >>> ---


            // --- Event Listeners ---

            // Controls
            addCardBtn.addEventListener('click', () => openEditModal());
            exportBtn.addEventListener('click', handleExport);
            importFileInput.addEventListener('change', handleImport); // Listener on hidden input
            //importBtnLabel.addEventListener('click', () => importFileInput.click()); // Trigger hidden input

            // Modal
            editForm.addEventListener('submit', handleSaveCard);
            cancelEditBtn.addEventListener('click', requestCloseModal);
            window.addEventListener('click', (event) => { // Close modal on outside click
                if (event.target === editModal) requestCloseModal();
            });

            // Filters & Search / Summarize
            showOpenOnlyCheckbox.addEventListener('change', () => {
                // Re-run AI search if active, otherwise just reload based on checkbox
                 // NOTE: This ONLY reloads based on the checkbox. If an AI search WAS active,
                 // the user needs to click Search/Summarize again with the new filter setting.
                 // Re-running search automatically might be confusing or costly.
                loadCards(null); // Simply reload based on the new checkbox state
            });
            aiSearchBtn.addEventListener('click', performAiSearch);
            aiSummarizeBtn.addEventListener('click', performAiSummarize); // <<< NEW: Summarize listener
            aiSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    // Decide whether Enter should trigger Search or Summarize?
                    // Let's default to Search for now.
                    performAiSearch();
                }
             });
            aiSearchInput.addEventListener('input', () => { if (aiSearchInput.value.trim() === '') loadCards(null); }); // Clear search on empty
            aiSearchInput.addEventListener('search', () => { if (aiSearchInput.value.trim() === '') loadCards(null); }); // Clear search on 'x' click

            // Drag and Drop Container Listeners
            cardContainer.addEventListener('dragover', handleDragOver);
            cardContainer.addEventListener('dragleave', handleDragLeaveContainer);
            cardContainer.addEventListener('drop', handleDrop);

			// --- Initialization ---
            async function initializeApp() {
                try {
                    // Check for Marked library
                    if (typeof marked === 'undefined' || typeof marked.parse !== 'function') {
                         console.error("FATAL: Marked.js library not found or failed to load. Markdown rendering will not work.");
                         alert("Error: Could not load the Markdown rendering library. Please check your internet connection or the console for errors.");
                         // Optionally disable features that depend on it
                    }

                    await openDb();
                    await loadCards(); // Initial load
                    console.log("Application initialized.");
                } catch (error) {
                    console.error("Initialization failed:", error);
                    document.body.innerHTML = `<p style="color: red; padding: 20px;">Error: Failed to initialize application. IndexedDB might be blocked or unavailable. ${error.message}</p>`;
                }
            }

            initializeApp(); // Start the application
        });
    </script>

</body>
</html>